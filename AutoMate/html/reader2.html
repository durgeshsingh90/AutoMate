<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced File Reader with XML Tag Count</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        #editor {
            width: 100%;
            height: 65vh;
            border: 1px solid #ccc;
            margin-bottom: 0;
        }

        #statusBar {
            display: flex;
            justify-content: space-between;
            background-color: #f1f1f1;
            padding: 4px 10px;
            font-size: 12px;
            border-top: 1px solid #ccc;
        }

        .fullscreen #editor {
            height: calc(100vh - 25px);
        }

        .fullscreen #statusBar {
            position: fixed;
            bottom: 0;
            width: 100%;
            z-index: 9999;
            background-color: #f1f1f1;
        }

        .status-item {
            margin: 0 5px;
        }

        .dark-mode {
            background-color: #121212;
            color: #ffffff;
        }

        .dark-mode .btn {
            background-color: #1f1f1f;
            color: #ffffff;
        }

        .dark-mode #editor {
            border-color: #333;
        }

        .dark-mode #statusBar {
            background-color: #333;
            color: #fff;
            border-top-color: #444;
        }

        .error-line {
            background-color: #ffdddd !important;
        }
    </style>
</head>
<body>
    <div class="container mt-3">
        <!-- Header with buttons -->
        <div class="d-flex justify-content-between align-items-center">
            <h1 id="page-title">Advanced File Reader with XML Tag Count</h1>
            <div>
                <button id="fullscreenButton" class="btn btn-warning">Full Screen</button>
                <button id="prettierButton" class="btn btn-success">Prettier</button>
                <button id="toggleDarkMode" class="btn btn-primary">Enable Dark Mode</button>
            </div>
        </div>

        <!-- File input -->
        <input type="file" id="fileInput" class="form-control mt-3" accept=".xml,.html,.py,.json,.yaml,.yml">
        <small class="text-muted">Select a Python, JSON, YAML, XML, or HTML file to load</small>

        <!-- Monaco Editor Container -->
        <div id="editor" class="mt-3"></div>

        <!-- Status Bar -->
        <div id="statusBar">
            <span id="lnCol" class="status-item">Ln 1, Col 1</span>
            <span id="spaces" class="status-item">Spaces: 2</span>
            <span id="utf" class="status-item">UTF-8</span>
            <span id="language" class="status-item">Language: plaintext</span>
            <span id="length" class="status-item">Length: 0</span>
            <span id="lines" class="status-item">Lines: 0</span>
            <span id="selection" class="status-item">Sel: 0</span>
            <span id="tagCount" class="status-item">Tags: 0</span>
        </div>
    </div>

    <!-- Monaco Editor loader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs/loader.min.js"></script>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        let editor;

        // Load Monaco Editor
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' }});
        require(['vs/editor/editor.main'], function() {
            const savedContent = localStorage.getItem('editorContent') || `# Load a Python, JSON, YAML, XML, or HTML file using the input above`;
            const savedLanguage = localStorage.getItem('editorLanguage') || 'plaintext';
            
            editor = monaco.editor.create(document.getElementById('editor'), {
                value: savedContent,
                language: savedLanguage,  // Language restored from localStorage
                theme: 'vs-light',
                folding: true,
                automaticLayout: true,
                scrollBeyondLastLine: false,
                lineNumbers: 'on',
                tabSize: 2 // Set tab size to 2 spaces as per your preference
            });

            // Restore file name in the file input
            const savedFileName = localStorage.getItem('editorFileName');
            if (savedFileName) {
                document.getElementById('fileInput').setAttribute('data-file-name', savedFileName);
                document.getElementById('fileInput').classList.add('file-loaded');
            }

            // Save editor content on change
            editor.onDidChangeModelContent(() => {
                localStorage.setItem('editorContent', editor.getValue());
                updateStatusBar();
                updateTagCount(editor.getValue());
            });

            // Update status bar on editor events
            editor.onDidChangeCursorPosition(updateStatusBar);
            editor.onDidChangeModelContent(updateStatusBar);

            // Update the tag count in the status bar if XML or HTML is detected
            updateTagCount(editor.getValue());
        });

        // Dark mode toggle
        document.getElementById('toggleDarkMode').addEventListener('click', function() {
            if (document.body.classList.contains('dark-mode')) {
                document.body.classList.remove('dark-mode');
                editor.updateOptions({ theme: 'vs-light' });
                this.textContent = 'Enable Dark Mode';
            } else {
                document.body.classList.add('dark-mode');
                editor.updateOptions({ theme: 'vs-dark' });
                this.textContent = 'Disable Dark Mode';
            }
        });

        // Full-screen toggle logic using the Fullscreen API
        document.getElementById('fullscreenButton').addEventListener('click', function() {
            const editorContainer = document.getElementById('editor').parentElement;
            if (!document.fullscreenElement) {
                editorContainer.requestFullscreen();
                this.textContent = 'Exit Full Screen';
            } else {
                document.exitFullscreen();
                this.textContent = 'Full Screen';
            }
        });

        // File upload logic
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    const language = determineLanguage(file.name);
                    monaco.editor.setModelLanguage(editor.getModel(), language);
                    editor.setValue(content);
                    // Save the content and file name to localStorage
                    localStorage.setItem('editorContent', content);
                    localStorage.setItem('editorFileName', file.name);
                    localStorage.setItem('editorLanguage', language);

                    // Update the tag count if it's XML/HTML
                    updateTagCount(content);
                };
                reader.readAsText(file);
            }
        });

        // Determine language by file extension
        function determineLanguage(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            switch (ext) {
                case 'xml':
                    return 'xml';
                case 'html':
                    return 'html';
                case 'py':
                    return 'python';
                case 'json':
                    return 'json';
                case 'yaml':
                case 'yml':
                    return 'yaml';
                default:
                    return 'plaintext';
            }
        }

        // Prettier functionality with improved XML formatting
        document.getElementById('prettierButton').addEventListener('click', function() {
            const model = editor.getModel();  // Correctly get the model
            const language = model.getLanguageId();  // Use getLanguageId() to get the language
            let content = editor.getValue();

            try {
                if (language === 'json') {
                    content = JSON.stringify(JSON.parse(content), null, 4);
                } else if (language === 'yaml' || language === 'yml') {
                    content = jsyaml.dump(jsyaml.load(content), { indent: 2 });  // 2 spaces for YAML
                } else if (language === 'python') {
                    content = js_beautify(content, { indent_size: 2 });  // 2 spaces for Python
                } else if (language === 'xml' || language === 'html') {
                    content = formatXml(content);  // Improved XML formatting function
                } else {
                    throw new Error("Prettier is only available for JSON, YAML, Python, XML, and HTML");
                }
                editor.setValue(content);
                localStorage.setItem('editorContent', content); // Save formatted content

                // Update the tag count if it's XML/HTML
                updateTagCount(content);
            } catch (err) {
                highlightError(err.message);
            }
        });

        // Improved custom XML formatter function
        function formatXml(xml) {
            let formatted = '';
            const reg = /(>)(<)(\/*)/g;
            xml = xml.replace(reg, '$1\r\n$2$3');

            // Split inline tags like <tag>...</tag><tag>...</tag> onto separate lines
            xml = xml.replace(/>\s*</g, '>\n<');

            let pad = 0;
            xml.split('\n').forEach(function(node) {
                let indent = 0;
                if (node.match(/.+<\/\w[^>]*>$/)) {
                    indent = 0;
                } else if (node.match(/^<\/\w/)) {
                    if (pad !== 0) {
                        pad -= 1;
                    }
                } else if (node.match(/^<\w([^>]*[^\/])?>.*$/)) {
                    indent = 1;
                } else {
                    indent = 0;
                }
                const padding = new Array(pad + 1).join('  ');
                formatted += padding + node + '\n';
                pad += indent;
            });
            return formatted.trim();  // Remove trailing newline
        }

        // Highlight error in editor
        function highlightError(errorMessage) {
            const errorMatch = errorMessage.match(/line (\d+)/);
            if (errorMatch && errorMatch[1]) {
                const lineNumber = parseInt(errorMatch[1], 10);
                editor.deltaDecorations([], [{
                    range: new monaco.Range(lineNumber, 1, lineNumber, 1),
                    options: { isWholeLine: true, className: 'error-line' }
                }]);
                alert(`Error on line ${lineNumber}: ${errorMessage}`);
            } else {
                alert(`Error: ${errorMessage}`);
            }
        }

        // Update status bar
        function updateStatusBar() {
            const model = editor.getModel();
            const language = model.getLanguageId();  // Correctly get the language
            const position = editor.getPosition();
            const selection = editor.getSelection();
            const selectionLength = editor.getModel().getValueInRange(selection).length;  // Correct selection length

            document.getElementById('lnCol').textContent = `Ln ${position.lineNumber}, Col ${position.column}`;
            document.getElementById('spaces').textContent = `Spaces: 2`;  // Changed to 2 spaces
            document.getElementById('utf').textContent = `UTF-8`;
            document.getElementById('language').textContent = `Language: ${language}`;  // Correctly set language
            document.getElementById('length').textContent = `Length: ${editor.getValue().length}`;
            document.getElementById('lines').textContent = `Lines: ${model.getLineCount()}`;
            document.getElementById('selection').textContent = `Sel: ${selectionLength}`;  // Correct selection count
        }

        // Function to update the number of tags (XML/HTML)
        function updateTagCount(content) {
            const tagRegex = /<[^>]+>/g;
            const tagMatches = content.match(tagRegex);
            const tagCount = tagMatches ? tagMatches.length : 0;
            document.getElementById('tagCount').textContent = `Tags: ${tagCount}`;
        }
    </script>
</body>
</html>
